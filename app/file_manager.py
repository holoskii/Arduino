
import os, signal, subprocess, pickle, numpy as np, tkinter as tk
import time, matplotlib.animation as mpl_animation
from tkinter import messagebox
from typing import List, Dict
from datetime import datetime
from collections import defaultdict
from matplotlib.figure import Figure
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg

class FileParser:
    start_prefix: str = "START: "
    info_prefix:  str = "INFO: "

    def __init__(self, output_file_path: str):
        self.output_file_path:  str         = output_file_path
        self.last_point_time:   int         = 0
        self.time_values:       List[float] = []
        self.temp1_values:      List[float] = []
        self.control1_values:   List[float] = []
        self.temp2_values:      List[float] = []
        self.control2_values:   List[float] = []
        self.max_time_value:    float       = 0
        self.arduino_param_str: str         = 'No data'
        self.title:             str         = ''

    def read_file(self):
        start = time.time()
        with open(self.output_file_path, 'r') as file:
            for line in file:
                if line.startswith(self.start_prefix):
                    self.arduino_param_str = line[len(self.start_prefix):-1]
                    continue

                if not line.startswith(self.info_prefix):
                    continue    
                
                numbers: List[float] = []
                for part in line[len(self.info_prefix):].split(','):
                    numbers.append(float(part))

                if len(numbers) != 5:
                    print(f"Unexpected number count \"{len(numbers)}\" in info line \"{line}\"")
                    continue

                self.time_values    .append(self.last_point_time / 60)
                self.temp1_values   .append(numbers[1])
                self.control1_values.append(numbers[2])
                self.temp2_values   .append(numbers[3])
                self.control2_values.append(numbers[4])
                self.max_time_value = max(self.max_time_value, self.last_point_time / 60 )
                self.last_point_time += 1
        
        end = time.time()
        # print("File parsing time = {:.0f} ms".format(1000 * (end - start)))
    
        temp1 = self.temp1_values[-1] if len(self.temp1_values) > 0 else 0
        temp2 = self.temp2_values[-1] if len(self.temp2_values) > 0 else 0
        temps_str = "Substrate Blue {:3.01f}°C, Source Red: {:3.01f}°C".format(temp1, temp2)
        date_time_now = datetime.now()
        d = date_time_now.strftime("%H:%M:%S, %d %b, %Y")
        self.title = f'{self.arduino_param_str}\n{temps_str}; {d}'
        return self

class FileManager:
    @staticmethod
    def clear_file(output_file_path):
        with open(output_file_path, 'w') as file:
            file.truncate(0)

    @staticmethod
    def write_to_header(header_file_path, parameters_entries, labels):
        # Get values from the Entry fields
        substrate_values = [parameters_entries['Substrate'][label].get() for label in labels]
        source_values = [parameters_entries['Source'][label].get() for label in labels]

        # Verify the values are valid floats
        for value in substrate_values + source_values + [parameters_entries['Additional']['Timer'].get()] + [parameters_entries['Additional']['Interval temp'].get()]:
            try:
                float(value)
            except ValueError:
                raise ValueError("Invalid float value: {}".format(value))

        # Create the lines for the header file
        header_lines = []
        header_lines.append("/* DO NOT EDIT, AUTOGENERATED FROM gui.py */\n\n")
        header_lines.append("static constexpr int        SUBSTRATE_TEMP        = {};\n".format(substrate_values[0]))
        header_lines.append("static constexpr int        SUBSTRATE_TEMP_OFFSET = {};\n".format(substrate_values[1]))
        header_lines.append("static constexpr double     SUBSTRATE_KP          = {};\n".format(substrate_values[2]))
        header_lines.append("static constexpr double     SUBSTRATE_KD          = {};\n".format(substrate_values[3]))
        header_lines.append("\n")
        header_lines.append("static constexpr int        SOURCE_TEMP           = {};\n".format(source_values[0]))
        header_lines.append("static constexpr int        SOURCE_TEMP_OFFSET    = {};\n".format(source_values[1]))
        header_lines.append("static constexpr double     SOURCE_KP             = {};\n".format(source_values[2]))
        header_lines.append("static constexpr double     SOURCE_KD             = {};\n".format(source_values[3]))
        header_lines.append("\n")
        header_lines.append("static constexpr unsigned long DEPOSITION_TIME_MS = {};\n".format(int(parameters_entries['Additional']['Timer'].get()) * 60 * 1000))

        # Write to the header file
        with open(header_file_path, "w") as header_file:
            header_file.writelines(header_lines)

        print("Header file has been written: \n>>>")
        with open(header_file_path, "r") as header_file:
            print(header_file.read())
        print("<<<")

    # Functions to save and load data
    @staticmethod
    def save_data(data, filename):
        # Create a copy of data with text content only
        text_data = {k1: {k2: v2.get() for k2, v2 in v1.items()} for k1, v1 in data.items()}
        with open(filename, 'wb') as output:
            pickle.dump(text_data, output)

    @staticmethod
    def load_data(data, filename):
        try:
            with open(filename, 'rb') as input:
                loaded_data = pickle.load(input)
        except Exception as e:
            messagebox.showerror(title=None, message="This safe file doesn't exist yet")
        # Update the text content of each Entry widget
        for k1, v1 in loaded_data.items():
            for k2, v2 in v1.items():
                data[k1][k2].delete(0, tk.END)
                data[k1][k2].insert(0, v2)