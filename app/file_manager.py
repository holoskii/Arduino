import pickle, tkinter as tk
import time
from CTkMessagebox import CTkMessagebox
from typing import List
from datetime import datetime
import csv

from my_timer import Timer


class FileParser:
    start_prefix: str = "START: "
    info_prefix:  str = "INFO: "

    def __init__(self, output_file_path: str):
        self.output_file_path:  str         = output_file_path
        self.last_point_time:   int         = 0
        self.time_values:       List[float] = []
        self.temp1_values:      List[float] = []
        self.control1_values:   List[float] = []
        self.temp2_values:      List[float] = []
        self.control2_values:   List[float] = []
        self.max_time_value:    float       = 0
        self.arduino_param_str: str         = 'No data'
        self.title:             str         = ''

    def read_file(self):
        t = Timer()
        with open(self.output_file_path, 'r') as file:
            for line in file:
                if line.startswith(self.start_prefix):
                    self.arduino_param_str = line[len(self.start_prefix):-1]
                    continue

                if not line.startswith(self.info_prefix):
                    continue    
                
                numbers: List[float] = []
                for part in line[len(self.info_prefix):].split(','):
                    numbers.append(float(part))

                if len(numbers) != 5:
                    print(f"Unexpected number count \"{len(numbers)}\" in info line \"{line}\"")
                    continue

                self.time_values    .append(self.last_point_time / 60)
                self.temp1_values   .append(numbers[1])
                self.control1_values.append(numbers[2])
                self.temp2_values   .append(numbers[3])
                self.control2_values.append(numbers[4])
                self.max_time_value = max(self.max_time_value, self.last_point_time / 60 )
                self.last_point_time += 1
        
        temp1 = self.temp1_values[-1] if len(self.temp1_values) > 0 else 0
        temp2 = self.temp2_values[-1] if len(self.temp2_values) > 0 else 0
        temps_str = "Substrate Blue {:3.01f}°C, Source Red: {:3.01f}°C".format(temp1, temp2)
        date_time_now = datetime.now()
        d = date_time_now.strftime("%H:%M:%S, %d %b, %Y")
        self.title = f'{self.arduino_param_str}\n{temps_str}; {d}'
        
        t.stop("File parsing")
        
        return self

class FileManager:
    @staticmethod
    def clear_file(output_file_path):
        print("Clearing file")
        with open(output_file_path, 'w') as file:
            file.truncate(0)

    @staticmethod
    def write_to_header(header_file_path, parameters_entries):
        # Get values from the Entry fields
        substrate_values = [entry.get() for entry in parameters_entries['Substrate'].values()]
        source_values = [entry.get() for entry in parameters_entries['Source'].values()]
        
        # Verify the values are valid floats
        for value in substrate_values + source_values + [parameters_entries['Additional']['Timer'].get()] + [parameters_entries['Additional']['Interval temp'].get()]:
            try:
                float(value)
            except ValueError:
                raise ValueError("Invalid float value: {}".format(value))

        # Create the lines for the header file
        header_lines = []
        header_lines.append("/* DO NOT EDIT, AUTOGENERATED FROM gui.py */\n\n")
        header_lines.append("static constexpr int        SUBSTRATE_TEMP        = {};\n".format(substrate_values[0]))
        header_lines.append("static constexpr int        SUBSTRATE_TEMP_OFFSET = {};\n".format(substrate_values[1]))
        header_lines.append("static constexpr double     SUBSTRATE_KP          = {};\n".format(substrate_values[2]))
        header_lines.append("static constexpr double     SUBSTRATE_KD          = {};\n".format(substrate_values[3]))
        header_lines.append("\n")
        header_lines.append("static constexpr int        SOURCE_TEMP           = {};\n".format(source_values[0]))
        header_lines.append("static constexpr int        SOURCE_TEMP_OFFSET    = {};\n".format(source_values[1]))
        header_lines.append("static constexpr double     SOURCE_KP             = {};\n".format(source_values[2]))
        header_lines.append("static constexpr double     SOURCE_KD             = {};\n".format(source_values[3]))
        header_lines.append("\n")
        header_lines.append("static constexpr unsigned long DEPOSITION_TIME_MS = {};\n".format(int(parameters_entries['Additional']['Timer'].get()) * 60 * 1000))

        # Write to the header file
        with open(header_file_path, "w") as header_file:
            header_file.writelines(header_lines)

        print("Header file has been written: \n>>>")
        with open(header_file_path, "r") as header_file:
            print(header_file.read())
        print("<<<")

    # Functions to save and load data
    @staticmethod
    def save_data(data, filename):
        # Create a copy of data with text content only
        text_data = {k1: {k2: v2.get() for k2, v2 in v1.items()} for k1, v1 in data.items()}
        with open(filename, 'wb') as output:
            pickle.dump(text_data, output)

    @staticmethod
    def load_data(data, filename, show_error=True, load_filenames=False):
        try:
            with open(filename, 'rb') as input:
                loaded_data = pickle.load(input)
        except Exception as e:
            if show_error:
                CTkMessagebox(title="Error", message="This savefile doesn't exist yet")
            return
        # Update the text content of each Entry widget
        for k1, v1 in loaded_data.items():
            for k2, v2 in v1.items():
                if k1 == 'Savenames' and not load_filenames:
                    continue
                data[k1][k2].delete(0, tk.END)
                data[k1][k2].insert(0, v2)

    @staticmethod
    def save_graph_data(input_file_path, parameters_entries):
        output_filename:str = str(parameters_entries['Additional']['Name'].get())
        print("Saving file to " + output_filename)

        reader = FileParser(input_file_path).read_file()

        timer = Timer()
        with open(f'data/{output_filename}_data.csv', 'w', newline='') as output_file:
            writer = csv.writer(output_file)
            writer.writerow(['Index', 'Temp1', 'Temp2'])

            for i, (temp1, temp2) in enumerate(zip(reader.temp1_values, reader.temp2_values), 1):
                writer.writerow([i, temp1, temp2])
        
        timer.stop("File write time")
